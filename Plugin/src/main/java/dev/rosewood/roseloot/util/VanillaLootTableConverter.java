package dev.rosewood.roseloot.util;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import dev.rosewood.rosegarden.utils.NMSUtil;
import dev.rosewood.roseloot.RoseLoot;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import net.md_5.bungee.api.chat.TextComponent;
import net.md_5.bungee.chat.ComponentSerializer;
import org.bukkit.Bukkit;
import org.bukkit.Material;
import org.bukkit.loot.LootTables;
import org.bukkit.map.MapView;

@SuppressWarnings("deprecation")
public final class VanillaLootTableConverter {

    private static final String OR_PATTERN = "||";
    private static final String AND_PATTERN = "&&";
    private static final String NAMESPACE = "minecraft:";
    private static final int NAMESPACE_LENGTH = NAMESPACE.length();

    private static final String[] HEADER = new String[] {
            "# ###################################################################################### #",
            "#                     !!! READ BEFORE USING OR EDITING THIS FILE !!!                     #",
            "#                THIS IS ONLY AN EXAMPLE FILE AND IS NOT USED BY DEFAULT                 #",
            "#   If you wish to use this file, copy it to the 'plugins/RoseLoot/loottables' folder    #",
            "#  DO NOT COPY EVERY EXAMPLE FILE INTO THE LOOTTABLES FOLDER, ONLY THE ONES YOU MODIFY!  #",
            "#         This file was auto-generated by RoseLoot based on a vanilla loot table         #",
            "# ###################################################################################### #"
    };

    public static void convertVanilla(File destination) {
        File vanillaDirectory = new File(destination, "vanilla");
        vanillaDirectory.mkdirs();

        for (LootTables lootTables : LootTables.values()) {
            if (lootTables.name().equals("EMPTY"))
                continue;

            String path = lootTables.getKey().getKey();
            handleVanilla(vanillaDirectory, path);
        }

        for (Material material : Material.values())
            handleVanilla(vanillaDirectory, "blocks/" + material.name().toLowerCase());
    }

    public static void convertDirectory(File directory, File destination) {
        try (Stream<Path> walker = Files.walk(Paths.get(directory.getPath()))) {
            walker.filter(Files::isRegularFile).forEach(path -> {
                File file = path.toFile();
                if (!file.getName().endsWith(".json"))
                    return;

                String pathString = file.getPath().replace(directory.getPath(), "");
                pathString = pathString.substring(1, pathString.length() - 5);

                try (InputStream inputStream = Files.newInputStream(path, StandardOpenOption.READ)) {
                    File destinationFile = new File(destination, pathString + ".yml");
                    destinationFile.delete();
                    handleInputStream(destinationFile, inputStream, pathString, false);
                } catch (Exception e) {
                    RoseLoot.getInstance().getLogger().warning("Failed to convert loot table: " + directory.toPath().relativize(path));
                    e.printStackTrace();
                }
            });
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private static void handleVanilla(File directory, String path) {
        File destination = new File(directory, path + ".yml");
        if (destination.exists())
            return;

        String lootTableDirectoryName = NMSUtil.getVersionNumber() >= 21 ? "loot_table" : "loot_tables"; // why
        try (InputStream inputStream = Bukkit.class.getClassLoader().getResourceAsStream("data/minecraft/" + lootTableDirectoryName + "/" + path + ".json")) {
            if (inputStream == null)
                return;

            handleInputStream(destination, inputStream, path, true);
        } catch (Exception e) {
            RoseLoot.getInstance().getLogger().warning("Failed to create example file from vanilla loot table: " + path);
            e.printStackTrace();
            destination.delete();
        }
    }

    private static void handleInputStream(File destination, InputStream inputStream, String path, boolean includeWarning) throws IOException {
        JsonElement json = new JsonParser().parse(new InputStreamReader(inputStream, StandardCharsets.UTF_8));

        destination.getParentFile().mkdirs();
        destination.createNewFile();

        try (FileWriter fileWriter = new FileWriter(destination, StandardCharsets.UTF_8)) {
            IndentedFileWriter writer = new IndentedFileWriter(fileWriter);

            // Write warning header
            if (includeWarning)
                for (String headerLine : HEADER)
                    writer.write(headerLine);

            if ((path.startsWith("entities") && !path.equals("entities/sheep"))
                    || path.equals("charged_creeper/root")) {
                writeEntityHeader(path, writer);
            } else if (path.startsWith("blocks")) {
                writeBlockHeader(path, writer);
            } else if (path.equals("gameplay/fishing")) {
                writeFishingHeader(path, writer);
            } else if (path.contains("chests/trial_chambers/reward")) {
                if (path.equals("chests/trial_chambers/reward") || path.equals("chests/trial_chambers/reward_ominous")) {
                    writeVaultHeader(path, writer);
                } else {
                    writeLootTableHeader(path, writer);
                }
            } else if (path.startsWith("chests") || path.startsWith("dispensers") || path.startsWith("pots")) {
                writeContainerHeader(path, writer);
            } else if (path.equals("gameplay/piglin_bartering")) {
                writePiglinBarteringHeader(path, writer);
            } else if (path.equals("gameplay/cat_morning_gift")
                    || path.startsWith("gameplay/hero_of_the_village")
                    || path.startsWith("gameplay/panda_sneeze")
                    || path.startsWith("gameplay/sniffer_digging")
                    || (path.startsWith("shearing/") && path.lastIndexOf('/') < 9)
                    || path.startsWith("gameplay/turtle_grow")
                    || path.startsWith("gameplay/brush/armadillo")) {
                writeEntityDropsHeader(path, writer);
            } else if (path.startsWith("archaeology")) {
                writeArchaeologyHeader(path, writer);
            } else if (path.startsWith("harvest/") || path.startsWith("carve/")) {
                writeHarvestHeader(path, writer);
            } else {
                writeLootTableHeader(path, writer);
            }

            writeTableContents(path, writer, json.getAsJsonObject());
        }
    }

    private static void writeEntityHeader(String path, IndentedFileWriter writer) throws IOException {
        writer.write("type: ENTITY");
        writer.write("overwrite-existing: items");
        writer.write("conditions:");
        writer.increaseIndentation();
        String entityType = path.substring("entities/".length());
        entityType = fixEntityNames(entityType);
        if (entityType.startsWith("sheep")) {
            writer.write("- 'entity-type:sheep'");
            writer.write("- 'sheep-color:" + entityType.substring("sheep/".length()) + "'");
        } else {
            writer.write("- 'entity-type:" + entityType + "'");
        }
        writer.decreaseIndentation();
    }

    private static void writeBlockHeader(String path, IndentedFileWriter writer) throws IOException {
        writer.write("type: BLOCK");
        writer.write("overwrite-existing: items");
        writer.write("conditions:");
        writer.increaseIndentation();
        writer.write("- 'block-type:" + path.substring("blocks/".length()) + "'");
        writer.decreaseIndentation();
    }

    private static void writeFishingHeader(String path, IndentedFileWriter writer) throws IOException {
        writer.write("type: FISHING");
        writer.write("overwrite-existing: items");
        writer.write("conditions: []");
    }

    private static void writeContainerHeader(String path, IndentedFileWriter writer) throws IOException {
        writer.write("type: CONTAINER");
        writer.write("overwrite-existing: items");
        writer.write("conditions:");
        writer.increaseIndentation();
        writer.write("- 'vanilla-loot-table:" + path + "'");
        writer.decreaseIndentation();
    }

    private static void writePiglinBarteringHeader(String path, IndentedFileWriter writer) throws IOException {
        writer.write("type: PIGLIN_BARTER");
        writer.write("overwrite-existing: items");
        writer.write("conditions: []");
    }

    private static void writeEntityDropsHeader(String path, IndentedFileWriter writer) throws IOException {
        writer.write("type: ENTITY_DROP_ITEM");
        writer.write("overwrite-existing: items");
        writer.write("conditions:");
        writer.increaseIndentation();
        if (path.startsWith("gameplay/cat_morning_gift")) {
            writer.write("- 'entity-type:cat'");
        } else if (path.startsWith("gameplay/panda_sneeze")) {
            writer.write("- 'entity-type:panda'");
        } else if (path.startsWith("gameplay/sniffer_digging")) {
            writer.write("- 'entity-type:sniffer'");
        } else if (path.startsWith("gameplay/hero_of_the_village")) {
            writer.write("- 'entity-type:villager'");
            writer.write("- 'villager-profession:" + path.substring("gameplay/hero_of_the_village/".length(), path.length() - "_gift".length()) + "'");
        } else if (path.startsWith("shearing/bogged")) {
            writer.write("- 'entity-type:bogged'");
        } else if (path.startsWith("shearing/snow_golem")) {
            writer.write("- 'entity-type:snow_golem'");
        } else if (path.startsWith("shearing/sheep")) {
            writer.write("- 'entity-type:sheep'");
        } else if (path.startsWith("shearing/mooshroom")) {
            writer.write("- 'entity-type:mooshroom'");
            if (!path.equals("shearing/mooshroom")) {
                if (path.endsWith("red")) {
                    writer.write("- 'mooshroom-variant:red'");
                } else if (path.endsWith("brown")) {
                    writer.write("- 'mooshroom-variant:brown'");
                } else {
                    RoseLoot.getInstance().getLogger().warning("Unhandled entity drops mooshroom type: " + path);
                }
            }
        } else if (path.startsWith("brush/armadillo")) {
            writer.write("- 'entity-type:armadillo'");
        } else if (path.startsWith("gameplay/turtle_grow")) {
            writer.write("- 'entity-type:turtle'");
        } else if (path.startsWith("charged_creeper/root")) {
            writer.write("- 'charged-explosion'");
        } else {
            RoseLoot.getInstance().getLogger().warning("Unhandled entity drops loot table type: " + path);
        }
        writer.decreaseIndentation();
    }

    private static void writeArchaeologyHeader(String path, IndentedFileWriter writer) throws IOException {
        writer.write("type: ARCHAEOLOGY");
        writer.write("overwrite-existing: items");
        writer.write("conditions:");
        writer.increaseIndentation();
        writer.write("- 'vanilla-loot-table:" + path + "'");
        writer.decreaseIndentation();
    }

    private static void writeVaultHeader(String path, IndentedFileWriter writer) throws IOException {
        writer.write("type: VAULT");
        writer.write("overwrite-existing: items");
        writer.write("conditions:");
        writer.increaseIndentation();
        if (path.contains("spawners/")) {
            writer.write("- 'block-type:trial_spawner'");
        } else {
            writer.write("- 'block-type:vault'");
        }
        //writer.write("- 'vanilla-loot-table:" + path + "'");
        if (path.contains("ominous")) {
            writer.write("- 'ominous'");
        } else {
            writer.write("- '!ominous'");
        }
        writer.decreaseIndentation();
    }

    private static void writeHarvestHeader(String path, IndentedFileWriter writer) throws IOException {
        writer.write("type: HARVEST");
        writer.write("overwrite-existing: items");
        writer.write("conditions:");
        writer.increaseIndentation();
        if (path.startsWith("harvest/beehive")) {
            writer.write("- 'block-type:#beehives'");
        } else if (path.startsWith("harvest/cave_vine")) {
            writer.write("- 'block-type:#cave_vines'");
        } else if (path.startsWith("harvest/sweet_berry_bush")) {
            writer.write("- 'block-type:sweet_berry_bush'");
        } else if (path.startsWith("carve/pumpkin")) {
            writer.write("- 'block-type:pumpkin'");
        }

        else {
            RoseLoot.getInstance().getLogger().warning("Unhandled harvest loot table type: " + path);
        }
        writer.decreaseIndentation();
    }

    private static void writeLootTableHeader(String path, IndentedFileWriter writer) throws IOException {
        writer.write("type: LOOT_TABLE");
    }

    private static void writeTableContents(String path, IndentedFileWriter writer, JsonObject json) throws IOException {
        JsonElement poolsElement = json.get("pools");
        if (poolsElement == null && !path.startsWith("entities/")) {
            writer.write("pools: {}");
            return;
        }

        writer.write("pools:");
        writer.increaseIndentation();

        int poolIndex = 0;
        if (poolsElement != null) {
            JsonArray pools = poolsElement.getAsJsonArray();
            for (; poolIndex < pools.size(); poolIndex++) {
                JsonObject pool = pools.get(poolIndex).getAsJsonObject();
                writer.write(poolIndex + ":");
                writer.increaseIndentation();

                writeItemConditions(path, writer, pool);
                writeNumberProvider("rolls", "rolls", writer, pool, 1.0);
                writeNumberProvider("bonus-rolls", "bonus_rolls", writer, pool, null);

                if (path.contains("entities/sheep/") && poolIndex == 0) {
                    // Manually add the sheared condition since this check is normally handled outside of loot tables
                    writer.write("conditions:");
                    writer.increaseIndentation();
                    writer.write("- '!sheep-sheared'");
                    writer.decreaseIndentation();
                }

                JsonElement entriesElement = pool.get("entries");
                if (entriesElement == null) {
                    writer.write("entries: {}");
                    continue;
                }

                writeEntries(path, "entries", writer, entriesElement.getAsJsonArray());

                writer.decreaseIndentation();
            }
        }

        // Manually add special items since they are handled outside of loot tables
        if (path.equals("entities/wither") || path.equals("entities/armor_stand")) {
            String item = path.equals("entities/wither") ? "nether_star" : "armor_stand";
            writer.write(poolIndex++ + ":");
            writer.increaseIndentation();
            writer.write("conditions: []");
            writer.write("rolls: 1");
            writer.write("bonus-rolls: 0");
            writer.write("entries:");
            writer.increaseIndentation();
            writer.write("0:");
            writer.increaseIndentation();
            writer.write("conditions: []");
            writer.write("items:");
            writer.increaseIndentation();
            writer.write("0:");
            writer.increaseIndentation();
            writer.write("type: item");
            writer.write("item: " + item);
            writer.write("amount: 1");
            writer.decreaseIndentation();
            writer.decreaseIndentation();
            writer.decreaseIndentation();
            writer.decreaseIndentation();
            writer.decreaseIndentation();
        }

        // Entity equipment
        if (path.startsWith("entities/")) {
            writer.write(poolIndex++ + ":");
            writer.increaseIndentation();
            writer.write("conditions: []");
            writer.write("rolls: 1");
            writer.write("bonus-rolls: 0");
            writer.write("entries:");
            writer.increaseIndentation();
            writer.write("0:");
            writer.increaseIndentation();
            writer.write("conditions: []");
            writer.write("items:");
            writer.increaseIndentation();
            writer.write("0:");
            writer.increaseIndentation();
            writer.write("type: entity_equipment");
            writer.decreaseIndentation();
            writer.decreaseIndentation();
            writer.decreaseIndentation();
            writer.decreaseIndentation();
            writer.decreaseIndentation();
        }

        // Charged creeper drops
        if (path.startsWith("entities/") && (NMSUtil.getVersionNumber() < 21 || (NMSUtil.getVersionNumber() == 21 && NMSUtil.getMinorVersionNumber() < 9))) {
            String entityType = path.substring(path.indexOf("/") + 1);
            String skullItem = switch (entityType) {
                case "zombie" -> "zombie_head";
                case "creeper" -> "creeper_head";
                case "skeleton" -> "skeleton_skull";
                case "wither_skeleton" -> "wither_skeleton_skull";
                case "piglin" -> "piglin_head";
                default -> null;
            };

            if (skullItem != null) {
                writer.write(poolIndex + ":");
                writer.increaseIndentation();
                writer.write("conditions:");
                writer.increaseIndentation();
                writer.write("- 'charged-explosion'");
                writer.decreaseIndentation();
                writer.write("rolls: 1");
                writer.write("bonus-rolls: 0");
                writer.write("entries:");
                writer.increaseIndentation();
                writer.write("0:");
                writer.increaseIndentation();
                writer.write("conditions: []");
                writer.write("items:");
                writer.increaseIndentation();
                writer.write("0:");
                writer.increaseIndentation();
                writer.write("type: item");
                writer.write("item: " + skullItem);
                writer.write("amount: 1");
                writer.decreaseIndentation();
                writer.decreaseIndentation();
                writer.decreaseIndentation();
                writer.decreaseIndentation();
                writer.decreaseIndentation();
            }
        }

        writer.decreaseIndentation();
    }

    private static void writeEntries(String path, String yamlName, IndentedFileWriter writer, JsonArray entries) throws IOException {
        writer.write(yamlName + ":");
        writer.increaseIndentation();

        for (int i = 0; i < entries.size(); i++) {
            JsonObject entry = entries.get(i).getAsJsonObject();
            writer.write(i + ":");
            writer.increaseIndentation();

            writeItemConditions(path, writer, entry);

            if (yamlName.equals("entries"))
                writeNumberProvider("weight", "weight", writer, entry, entries.size() == 1 ? null : 1.0);

            writeNumberProvider("quality", "quality", writer, entry, null);

            String type = entry.get("type").getAsString();
            switch (type) {
                case "minecraft:item" -> {
                    writer.write("items:");
                    writer.increaseIndentation();
                    writer.write("0:");
                    writer.increaseIndentation();
                    writer.write("type: item");
                    writer.write("item: " + trimNamespace(entry.get("name").getAsString()));
                    writeAmountModifiers(path, writer, entry);
                    writeItemFunctions(path, writer, entry);
                    writer.decreaseIndentation();
                    writer.decreaseIndentation();
                }
                case "minecraft:tag" -> {
                    writer.write("items:");
                    writer.increaseIndentation();
                    writer.write("0:");
                    writer.increaseIndentation();
                    writer.write("type: tag");
                    writer.write("tag: " + trimNamespace(entry.get("name").getAsString()));
                    writeAmountModifiers(path, writer, entry);
                    writeItemFunctions(path, writer, entry);
                    writer.decreaseIndentation();
                    writer.decreaseIndentation();
                }
                case "minecraft:loot_table" -> {
                    writer.write("items:");
                    writer.increaseIndentation();
                    writer.write("0:");
                    writer.increaseIndentation();
                    writer.write("type: loot_table");
                    if (entry.has("value")) {
                        JsonElement valueElement = entry.get("value");
                        if (valueElement.isJsonObject()) {
                            JsonObject valueObject = valueElement.getAsJsonObject();
                            writeTableContents(path + "/$minecraft:loot_table", writer, valueObject);
                        } else {
                            writer.write("value: " + trimNamespace(entry.get("value").getAsString()));
                        }
                    } else {
                        writer.write("value: " + trimNamespace(entry.get("name").getAsString()));
                    }
                    writer.decreaseIndentation();
                    writer.decreaseIndentation();
                }
                case "minecraft:dynamic" -> {
                    // Currently only used for decorated pots for dropping sherds dynamically
                    // It's also possible to use "container" to drop container contents, so handle that too
                    String name = entry.get("name").getAsString();
                    if (name.contains("container") || name.contains("sherds")) {
                        writer.write("items:");
                        writer.increaseIndentation();
                        writer.write("0:");
                        writer.increaseIndentation();
                        writer.write("type: container_contents");
                        writer.decreaseIndentation();
                        writer.decreaseIndentation();
                    } else {
                        RoseLoot.getInstance().getLogger().warning("Unhandled dynamic item type: " + name + " | " + path);
                    }
                }
                case "minecraft:alternatives" -> {
                    writer.write("children-strategy: first_passing");
                    JsonArray children = entry.get("children").getAsJsonArray();
                    writeEntries(path, "children", writer, children);
                }
                case "minecraft:group" -> {
                    writer.write("children-strategy: normal");
                    JsonArray children = entry.get("children").getAsJsonArray();
                    writeEntries(path, "children", writer, children);
                }
                case "minecraft:sequence" -> {
                    writer.write("children-strategy: sequential");
                    JsonArray children = entry.get("children").getAsJsonArray();
                    writeEntries(path, "children", writer, children);
                }
                case "minecraft:empty" -> writer.write("items: {}");
                default -> RoseLoot.getInstance().getLogger().warning("Unhandled item type: " + type + " | " + path);
            }

            writer.decreaseIndentation();
        }

        writer.decreaseIndentation();
    }

    private static void writeNumberProvider(String yamlName, String jsonName, IndentedFileWriter writer, JsonObject json, Double defaultValue) throws IOException {
        writeNumberProvider(yamlName, jsonName, writer, json, defaultValue, 1.0);
    }

    private static void writeNumberProvider(String yamlName, String jsonName, IndentedFileWriter writer, JsonObject json, Double defaultValue, double multiplier) throws IOException {
        JsonElement element = json.get(jsonName);
        if (element == null) {
            if (defaultValue != null) {
                String value = defaultValue.intValue() == defaultValue ? String.valueOf(defaultValue.intValue()) : defaultValue.toString();
                writer.write(yamlName + ": " + value);
            }
            return;
        }

        if (element.isJsonObject()) {
            JsonObject object = element.getAsJsonObject();
            JsonElement typeElement = object.get("type");
            String type;
            if (typeElement != null) {
                type = typeElement.getAsString();
            } else {
                type = "minecraft:uniform";
            }

            if (!type.equalsIgnoreCase("minecraft:constant")) {
                writer.write(yamlName + ":");
                writer.increaseIndentation();

                switch (type) {
                    case "minecraft:uniform" -> {
                        writeNumberProvider("min", "min", writer, object, 0.0, multiplier);
                        writeNumberProvider("max", "max", writer, object, 0.0, multiplier);
                    }
                    case "minecraft:binomial" -> {
                        writeNumberProvider("n", "n", writer, object, 0.0, multiplier);
                        writeNumberProvider("p", "p", writer, object, 0.0, multiplier);
                    }
                }
                writer.decreaseIndentation();
            } else {
                JsonElement valueElement = object.get("value");
                int intValue = (int) (valueElement.getAsInt() * multiplier);
                double doubleValue = valueElement.getAsDouble() * multiplier;
                if (intValue == doubleValue) {
                    writer.write(yamlName + ": " + intValue);
                } else {
                    writer.write(yamlName + ": " + doubleValue);
                }
            }
        } else if (element.isJsonPrimitive()) {
            int intValue = (int) (element.getAsInt() * multiplier);
            double doubleValue = element.getAsDouble() * multiplier;
            if (intValue == doubleValue) {
                writer.write(yamlName + ": " + intValue);
            } else {
                writer.write(yamlName + ": " + doubleValue);
            }
        }
    }

    private static void writeItemConditions(String path, IndentedFileWriter writer, JsonObject json) throws IOException {
        JsonElement conditionsElement = json.get("conditions");
        if (conditionsElement == null) {
            writer.write("conditions: []");
            return;
        }

        JsonArray conditions = conditionsElement.getAsJsonArray();
        if (conditions.size() == 0) {
            writer.write("conditions: []");
            return;
        }

        List<String> conditionList = new ArrayList<>();
        for (JsonElement conditionElement : conditions) {
            StringBuilder conditionBuilder = new StringBuilder();
            JsonObject condition = conditionElement.getAsJsonObject();
            buildConditionRecursively(path, conditionBuilder, condition);
            if (conditionBuilder.length() > 0)
                conditionList.add(conditionBuilder.toString());
        }

        if (!conditionList.isEmpty()) {
            writer.write("conditions:");
            writer.increaseIndentation();

            for (String value : conditionList)
                writer.write("- '" + value + "'");

            writer.decreaseIndentation();
        } else {
            writer.write("conditions: []");
        }
    }

    private static void buildConditionRecursively(String path, StringBuilder stringBuilder, JsonObject json) {
        String type = json.get("condition").getAsString();
        switch (type) {
            case "minecraft:inverted" -> {
                stringBuilder.append("!");
                StringBuilder tempBuilder = new StringBuilder();
                buildConditionRecursively(path, tempBuilder, json.get("term").getAsJsonObject());
                String temp = tempBuilder.toString();
                if (temp.contains(OR_PATTERN) || temp.contains(AND_PATTERN)) {
                    stringBuilder.append("(");
                    stringBuilder.append(temp);
                    stringBuilder.append(")");
                } else {
                    stringBuilder.append(temp);
                }
            }
            case "minecraft:alternative", "minecraft:any_of" -> {
                JsonArray alternativeTerms = json.get("terms").getAsJsonArray();
                Iterator<JsonElement> alternativeIterator = alternativeTerms.iterator();
                while (alternativeIterator.hasNext()) {
                    JsonElement termElement = alternativeIterator.next();
                    JsonObject term = termElement.getAsJsonObject();
                    buildConditionRecursively(path, stringBuilder, term);
                    if (alternativeIterator.hasNext())
                        stringBuilder.append(" " + OR_PATTERN + " ");
                }
            }
            case "minecraft:all_of" -> {
                JsonArray allOfTerms = json.get("terms").getAsJsonArray();
                Iterator<JsonElement> allOfIterator = allOfTerms.iterator();
                while (allOfIterator.hasNext()) {
                    JsonElement termElement = allOfIterator.next();
                    JsonObject term = termElement.getAsJsonObject();
                    buildConditionRecursively(path, stringBuilder, term);
                    if (allOfIterator.hasNext())
                        stringBuilder.append(" " + AND_PATTERN + " ");
                }
            }
            case "minecraft:random_chance" -> {
                JsonElement chanceElement = json.get("chance");
                if (chanceElement.isJsonPrimitive()) {
                    stringBuilder.append("chance:").append(LootUtils.getToMaximumDecimals(chanceElement.getAsDouble() * 100, 3)).append('%');
                } else {
                    RoseLoot.getInstance().getLogger().warning("minecraft:random_chance non-primitive values not supported");
                }
            }
            case "minecraft:random_chance_with_looting" -> {
                stringBuilder.append("enchantment-chance:");
                stringBuilder.append(LootUtils.getToMaximumDecimals(json.get("chance").getAsDouble() * 100, 3)).append("%,looting,");
                stringBuilder.append(LootUtils.getToMaximumDecimals(json.get("looting_multiplier").getAsDouble() * 100, 3)).append('%');
            }
            case "minecraft:random_chance_with_enchanted_bonus" -> {
                stringBuilder.append("enchantment-chance:");
                String enchantment = trimNamespace(json.get("enchantment").getAsString());
                double unenchantedChance = json.get("unenchanted_chance").getAsDouble();
                JsonObject enchantedChanceElement = json.get("enchanted_chance").getAsJsonObject();
                String chanceType = enchantedChanceElement.get("type").getAsString();
                switch (chanceType) {
                    case "minecraft:linear" -> {
                        double base = enchantedChanceElement.get("base").getAsDouble();
                        double perLevelAboveFirst = enchantedChanceElement.get("per_level_above_first").getAsDouble();
                        // Sanity check to make sure we aren't losing details
                        double expectedBase = unenchantedChance + perLevelAboveFirst;
                        if (Math.abs(base - expectedBase) > 0.0001) {
                            RoseLoot.getInstance().getLogger().warning("minecraft:random_chance_with_enchanted_bonus non-standard chance | " + path);
                            break;
                        }

                        stringBuilder.append(LootUtils.getToMaximumDecimals(unenchantedChance * 100, 3)).append("%,").append(enchantment).append(',');
                        stringBuilder.append(LootUtils.getToMaximumDecimals(perLevelAboveFirst * 100, 3)).append('%');
                    }
                    default -> {
                        RoseLoot.getInstance().getLogger().warning("minecraft:random_chance_with_enchanted_bonus unsupported chance type | " + chanceType + " | " + path);
                    }
                }
            }
            case "minecraft:table_bonus" -> {
                stringBuilder.append("enchantment-chance-table:");
                stringBuilder.append(trimNamespace(json.get("enchantment").getAsString())).append(',');
                JsonArray chancesElement = json.get("chances").getAsJsonArray();
                Iterator<JsonElement> chanceElementIterator = chancesElement.iterator();
                while (chanceElementIterator.hasNext()) {
                    double chance = chanceElementIterator.next().getAsDouble() * 100;
                    stringBuilder.append(LootUtils.getToMaximumDecimals(chance, 3)).append('%');
                    if (chanceElementIterator.hasNext())
                        stringBuilder.append(',');
                }
            }
            case "minecraft:block_state_property" -> {
                JsonObject properties = json.get("properties").getAsJsonObject();
                for (Map.Entry<String, JsonElement> entry : properties.entrySet())
                    stringBuilder.append("block-data:").append(entry.getKey()).append("=").append(entry.getValue().getAsString());
            }
            case "minecraft:killed_by_player" -> stringBuilder.append("killed-by:player");
            case "minecraft:match_tool" -> {
                JsonObject predicate = json.get("predicate").getAsJsonObject();
                JsonElement itemElement = predicate.get("item");
                JsonElement itemsElement = predicate.get("items");
                JsonElement predicatesElement = predicate.get("predicates");
                JsonElement enchantmentsElement = predicate.get("enchantments");
                JsonElement tagElement = predicate.get("tag");
                if (itemElement != null) {
                    stringBuilder.append("required-tool-type:");
                    stringBuilder.append(trimNamespace(itemElement.getAsString()));
                } else if (itemsElement != null) {
                    if (itemsElement.isJsonArray()) {
                        JsonArray items = itemsElement.getAsJsonArray();
                        Iterator<JsonElement> toolsIterator = items.iterator();
                        stringBuilder.append("required-tool-type:");
                        while (toolsIterator.hasNext()) {
                            JsonElement toolElement = toolsIterator.next();
                            stringBuilder.append(trimNamespace(toolElement.getAsString()));
                            if (toolsIterator.hasNext())
                                stringBuilder.append(',');
                        }
                    } else {
                        stringBuilder.append("required-tool-type:");
                        stringBuilder.append(trimNamespace(itemsElement.getAsString()));
                    }
                } else if (enchantmentsElement != null) {
                    JsonArray enchantments = enchantmentsElement.getAsJsonArray();
                    if (enchantments.size() > 0) {
                        JsonObject enchantment = enchantments.get(0).getAsJsonObject();
                        stringBuilder.append("enchantment:");
                        stringBuilder.append(trimNamespace(enchantment.get("enchantment").getAsString()));
                        JsonElement levels = enchantment.get("levels");
                        if (levels != null)
                            stringBuilder.append(',').append(levels.getAsJsonObject().get("min").getAsInt());
                    }
                } else if (tagElement != null) {
                    String tag = trimNamespace(tagElement.getAsString());
                    stringBuilder.append("required-tool-type:#").append(tag);
                } else if (predicatesElement != null) {
                    JsonObject predicatesObject = predicatesElement.getAsJsonObject();
                    for (String key : predicatesObject.keySet()) {
                        if (key.equals("minecraft:enchantments")) {
                            JsonArray enchantments = predicatesObject.get(key).getAsJsonArray();
                            if (enchantments.size() > 0) {
                                JsonObject enchantmentObject = enchantments.get(0).getAsJsonObject();
                                JsonElement enchantment = enchantmentObject.get("enchantment");
                                if (enchantment == null)
                                    enchantment = enchantmentObject.get("enchantments");
                                stringBuilder.append("enchantment:");
                                stringBuilder.append(trimNamespace(enchantment.getAsString()));
                                JsonElement levels = enchantmentObject.get("levels");
                                if (levels != null)
                                    stringBuilder.append(',').append(levels.getAsJsonObject().get("min").getAsInt());
                            }
                        } else {
                            RoseLoot.getInstance().getLogger().warning("minecraft:match_tool predicates unhandled value | " + key + " | " + path);
                        }
                    }
                } else {
                    RoseLoot.getInstance().getLogger().warning("minecraft:match_tool unhandled value | " + path);
                }
            }
            case "minecraft:damage_source_properties" -> {
                JsonObject damagePredicate = json.get("predicate").getAsJsonObject();
                List<String> causes = new ArrayList<>();
                Map<String, List<String>> causeMapping = new HashMap<>();
                causeMapping.put("bypasses_armor", List.of("suffocation"));
                causeMapping.put("bypasses_invulnerability", List.of("void", "custom"));
                causeMapping.put("bypasses_magic", List.of("starvation"));
                causeMapping.put("is_explosion", List.of("block_explosion", "entity_explosion"));
                causeMapping.put("is_fire", List.of("fire", "fire_tick"));
                causeMapping.put("is_magic", List.of("magic"));
                causeMapping.put("is_projectile", List.of("projectile"));
                causeMapping.put("is_lightning", List.of("lightning"));
                for (Map.Entry<String, JsonElement> entry : damagePredicate.entrySet()) {
                    if (causeMapping.containsKey(entry.getKey())) {
                        JsonElement element = entry.getValue();
                        if (element.getAsBoolean()) {
                            List<String> mappedValues = causeMapping.get(entry.getKey());
                            if (mappedValues != null)
                                causes.addAll(mappedValues);
                        }
                    } else if (entry.getKey().equalsIgnoreCase("source_entity")) {
                        JsonObject object = entry.getValue().getAsJsonObject();
                        String entityType = object.get("type").getAsString().replace("minecraft:", "");
                        if (entityType.equals("frog")) {
                            if (object.has("type_specific")) {
                                String variant = object.get("type_specific").getAsJsonObject().get("variant").getAsString().replace("minecraft:", "");
                                stringBuilder.append("killer-frog-variant:").append(variant);
                            } else {
                                stringBuilder.append("looter-entity-type:frog");
                            }
                        } else {
                            RoseLoot.getInstance().getLogger().warning("Unhandled minecraft:damage_source_properties source_entity type: " + entityType + " | " + path);
                        }
                    }
                }
                if (!causes.isEmpty()) {
                    stringBuilder.append("death-cause:");
                    Iterator<String> causeIterator = causes.iterator();
                    while (causeIterator.hasNext()) {
                        String cause = causeIterator.next();
                        stringBuilder.append(cause);
                        if (causeIterator.hasNext())
                            stringBuilder.append(',');
                    }
                }
            }
            case "minecraft:entity_properties" -> {
                List<String> propertyConditions = new ArrayList<>();
                JsonObject propertiesPredicate = json.get("predicate").getAsJsonObject();
                for (String propertyKey : propertiesPredicate.keySet()) {
                    switch (propertyKey.toLowerCase()) {
                        case "type_specific" -> {
                            JsonObject typeSpecificObject = propertiesPredicate.get("type_specific").getAsJsonObject();
                            String entityType = typeSpecificObject.get("type").getAsString().replace("minecraft:", "");
                            switch (entityType) {
                                case "slime" -> {
                                    propertyConditions.add("slime-size:1");
                                }
                                case "fishing_hook" -> {
                                    if (typeSpecificObject.get("in_open_water").getAsBoolean()) {
                                        propertyConditions.add("open-water");
                                    } else {
                                        propertyConditions.add("!open-water");
                                    }
                                }
                                case "raider" -> stringBuilder.append("patrol-leader");
                                case "sheep" -> {
                                    if (typeSpecificObject.has("color")) {
                                        String color = typeSpecificObject.get("color").getAsString();
                                        propertyConditions.add("sheep-color:" + color);
                                    }
                                    if (typeSpecificObject.has("sheared")) {
                                        if (typeSpecificObject.get("sheared").getAsBoolean()) {
                                            propertyConditions.add("sheep-sheared");
                                        } else {
                                            propertyConditions.add("!sheep-sheared");
                                        }
                                    }
                                }
                                case "mooshroom" -> {
                                    String variant = typeSpecificObject.get("variant").getAsString();
                                    propertyConditions.add("mooshroom-variant:" + variant);
                                }
                                default -> RoseLoot.getInstance().getLogger().warning("Unhandled minecraft:entity_properties type_specific value: " + entityType + " | " + path);
                            }
                        }
                        case "type" -> {
                            String entityType = propertiesPredicate.get("type").getAsString().replace("minecraft:", "");
                            entityType = fixEntityNames(entityType);

                            String entityTarget = json.get("entity").getAsString();
                            if (entityTarget.equals("killer")) {
                                propertyConditions.add("killed-by:" + entityType);
                            } else if (entityTarget.equals("this")) {
                                propertyConditions.add("entity-type:" + entityType);
                            }
                        }
                        case "fishing_hook" -> {
                            JsonObject fishingHookObject = propertiesPredicate.get("fishing_hook").getAsJsonObject();
                            if (fishingHookObject.get("in_open_water").getAsBoolean()) {
                                propertyConditions.add("open-water");
                            } else {
                                propertyConditions.add("!open-water");
                            }
                        }
                        case "flags" -> {
                            JsonObject flagsObject = propertiesPredicate.get("flags").getAsJsonObject();
                            for (String flagKey : flagsObject.keySet()) {
                                boolean flag = flagsObject.get(flagKey).getAsBoolean();
                                switch (flagKey) {
                                    case "is_baby" -> propertyConditions.add((flag ? "" : "!") + "baby");
                                    default -> RoseLoot.getInstance().getLogger().warning("Unhandled minecraft:entity_properties flag type: " + flagKey + " | " + path);
                                }
                            }
                        }
                        case "vehicle" -> {
                            JsonObject vehicleObject = propertiesPredicate.get("vehicle").getAsJsonObject();
                            String vehicleType = vehicleObject.get("type").getAsString().replace("minecraft:", "");
                            propertyConditions.add("vehicle:" + vehicleType);
                        }
                        case "components" -> {
                            JsonObject componentsObject = propertiesPredicate.get("components").getAsJsonObject();
                            for (String componentKey : componentsObject.keySet()) {
                                String componentValue = componentsObject.get(componentKey).getAsString().replace("minecraft:", "");
                                switch (componentKey.replace("minecraft:", "")) {
                                    case "sheep/color" -> propertyConditions.add("sheep-color:" + componentValue);
                                    case "chicken/variant" -> propertyConditions.add("chicken-variant:" + componentValue);
                                    case "mooshroom/variant" -> propertyConditions.add("mooshroom-variant:" + componentValue);
                                    default -> RoseLoot.getInstance().getLogger().warning("Unhandled minecraft:entity_properties components type: " + componentKey + " | " + path);
                                }
                            }
                        }
                        default -> RoseLoot.getInstance().getLogger().warning("Unhandled minecraft:entity_properties type: " + propertiesPredicate + " | " + path);
                    }
                }

                if (!propertyConditions.isEmpty())
                    stringBuilder.append(String.join(" && ", propertyConditions));
            }
            case "minecraft:location_check" -> {
                JsonObject locationPredicate = json.get("predicate").getAsJsonObject();
                if (locationPredicate.has("biome")) {
                    stringBuilder.append("biome:").append(trimNamespace(locationPredicate.get("biome").getAsString()));
                } else if (locationPredicate.has("biomes")) {
                    JsonElement biomesElement = locationPredicate.get("biomes");
                    if (biomesElement.isJsonArray()) {
                        stringBuilder.append("biome:").append(biomesElement.getAsJsonArray().asList()
                                .stream()
                                .map(JsonElement::getAsString)
                                .map(VanillaLootTableConverter::trimNamespace)
                                .collect(Collectors.joining(",")));
                    } else {
                        stringBuilder.append("biome:").append(trimNamespace(biomesElement.getAsString()));
                    }
                } else if (locationPredicate.has("block")) {
                    JsonObject blockObject = locationPredicate.get("block").getAsJsonObject();
                    if (blockObject.has("blocks")) {
                        JsonElement blocksObject = blockObject.get("blocks");
                        if (blocksObject.isJsonArray()) {
                            JsonArray blocksArray = blocksObject.getAsJsonArray();
                            if (blocksArray.size() > 0) {
                                int offsetY = 0;
                                if (json.has("offsetY"))
                                    offsetY = json.get("offsetY").getAsInt();

                                if (offsetY == 1) {
                                    stringBuilder.append("relative-block-type:north,");
                                } else if (offsetY == -1) {
                                    stringBuilder.append("relative-block-type:south,");
                                } else {
                                    stringBuilder.append("block-type:");
                                }

                                Iterator<JsonElement> blocksIterator = blocksArray.iterator();
                                while (blocksIterator.hasNext()) {
                                    stringBuilder.append(trimNamespace(blocksIterator.next().getAsString()));
                                    if (blocksIterator.hasNext())
                                        stringBuilder.append(',');
                                }
                            }
                        } else {
                            stringBuilder.append("block-type:").append(trimNamespace(blocksObject.getAsString()));
                        }
                    }
                } else if (locationPredicate.has("dimension")) {
                    String vanillaDimension = locationPredicate.get("dimension").getAsString();
                    String dimension = switch (vanillaDimension) {
                        case "minecraft:overworld" -> "normal";
                        case "minecraft:the_nether" -> "nether";
                        case "minecraft:the_end" -> "the_end";
                        default -> "custom";
                    };
                    stringBuilder.append("dimension:").append(dimension);
                } else {
                    RoseLoot.getInstance().getLogger().warning("Unhandled location_check type: " + locationPredicate + " | " + path);
                }
            }
            case "minecraft:survives_explosion" -> {
                // Ignored, still handled by vanilla logic
            }
            default -> RoseLoot.getInstance().getLogger().warning("Unhandled condition type: " + type + " | " + path);
        }
    }

    private static void writeAmountModifiers(String path, IndentedFileWriter writer, JsonObject json) throws IOException {
        JsonElement functionsElement = json.get("functions");
        if (functionsElement == null)
            return;

        List<AmountModifierData> amountModifiers = new ArrayList<>();

        JsonArray functions = functionsElement.getAsJsonArray();
        for (JsonElement functionElement : functions) {
            JsonObject function = functionElement.getAsJsonObject();
            String type = function.get("function").getAsString();
            if (!type.equals("minecraft:set_count"))
                continue;

            JsonElement conditionsElement = function.get("conditions");
            if (conditionsElement == null)
                continue;

            List<String> conditionList = new ArrayList<>();
            for (JsonElement conditionElement : conditionsElement.getAsJsonArray()) {
                StringBuilder conditionBuilder = new StringBuilder();
                JsonObject condition = conditionElement.getAsJsonObject();
                buildConditionRecursively(path, conditionBuilder, condition);
                if (conditionBuilder.length() > 0)
                    conditionList.add(conditionBuilder.toString());
            }

            boolean add = function.has("add") && function.get("add").getAsBoolean();
            amountModifiers.add(new AmountModifierData(conditionList, function, add));
        }

        if (!amountModifiers.isEmpty()) {
            writer.write("amount-modifiers:");
            writer.increaseIndentation();
            int i = 0;
            for (AmountModifierData amountModifier : amountModifiers) {
                writer.write(i++ + ":");
                writer.increaseIndentation();
                amountModifier.write(writer);
                writer.decreaseIndentation();
            }
            writer.decreaseIndentation();
        }
    }

    private static void writeItemFunctions(String path, IndentedFileWriter writer, JsonObject json) throws IOException {
        JsonElement functionsElement = json.get("functions");
        if (functionsElement == null)
            return;

        JsonArray functions = functionsElement.getAsJsonArray();
        for (JsonElement functionElement : functions) {
            JsonObject function = functionElement.getAsJsonObject();
            String name = json.get("name").getAsString();
            String type = function.get("function").getAsString();
            switch (type) {
                case "minecraft:set_count" -> {
                    if (function.has("conditions")) // set_count Conditions are handled in a different method
                        break;

                    if (path.contains("blocks/glow_lichen")) {
                        writer.write("amount: 0");
                        break;
                    }

                    writeNumberProvider("amount", "count", writer, function, 1.0);
                }
                case "minecraft:limit_count" -> {
                    JsonObject limitObject = function.get("limit").getAsJsonObject();
                    if (limitObject.has("max"))
                        writer.write("max-amount: " + limitObject.get("max").getAsNumber().intValue());
                }
                case "minecraft:set_damage" -> {
                    JsonObject damageObject = function.get("damage").getAsJsonObject();
                    JsonElement valueElement = damageObject.get("value");
                    if (valueElement != null) {
                         writer.write("durability: " + valueElement.getAsInt());
                    } else {
                        double min = damageObject.get("min").getAsDouble() * 100;
                        double max = damageObject.get("max").getAsDouble() * 100;
                        writer.write("durability:");
                        writer.increaseIndentation();
                        writer.write("min: " + min + "%");
                        writer.write("max: " + max + "%");
                        writer.decreaseIndentation();
                    }
                }
                case "minecraft:set_contents" -> {
                    if (name.contains("shulker")) {
                        writer.write("copy-block-state: true");
                    } else {
                        RoseLoot.getInstance().getLogger().warning("minecraft:set_contents unhandled: " + path);
                    }
                }
                case "minecraft:set_stew_effect" -> {
                    JsonArray effectsArray = function.get("effects").getAsJsonArray();
                    writer.write("pick-random-effect: true");
                    writer.write("custom-effects:");
                    writer.increaseIndentation();
                    int i = 0;
                    for (JsonElement effectElement : effectsArray) {
                        JsonObject effectObject = effectElement.getAsJsonObject();
                        writer.write(i++ + ":");
                        writer.increaseIndentation();
                        writer.write("effect: " + trimNamespace(effectObject.get("type").getAsString()));
                        writeNumberProvider("duration", "duration", writer, effectObject, 8.0, 20);
                        writer.decreaseIndentation();
                    }
                    writer.decreaseIndentation();
                }
                case "minecraft:set_enchantments" -> {
                    JsonObject enchantments = function.get("enchantments").getAsJsonObject();
                    writer.write("enchantments:");
                    writer.increaseIndentation();
                    for (Map.Entry<String, JsonElement> entry : enchantments.entrySet())
                        writeNumberProvider(trimNamespace(entry.getKey()), entry.getKey(), writer, enchantments, 0D);
                    writer.decreaseIndentation();
                }
                case "minecraft:set_name" -> {
                    // Somewhat unsupported due to a lack of Spigot API support for setting an item's name to a translation key
                    // This is currently only used for buried treasure maps generated in chests
                    String displayName = LootUtils.decolorize(new TextComponent(ComponentSerializer.parse(function.get("name").toString())).toLegacyText());
                    writer.write("display-name: '" + displayName.replaceAll(Pattern.quote("'"), "''") + "'");

                    // JsonObject nameObject = function.get("name").getAsJsonObject();
                    // writer.write("display-name: #" + trimNamespace(nameObject.get("translate").getAsString()));
                }
                case "minecraft:exploration_map" -> {
                    byte zoom = function.get("zoom").getAsByte();
                    boolean skipExistingChunks = function.get("skip_existing_chunks").getAsBoolean();
                    MapView.Scale scale = switch (zoom) {
                        case 0 -> MapView.Scale.CLOSEST;
                        case 1 -> MapView.Scale.CLOSE;
                        case 3 -> MapView.Scale.FAR;
                        case 4 -> MapView.Scale.FARTHEST;
                        default -> MapView.Scale.NORMAL;
                    };
                    writer.write("destination: mansion");
                    writer.write("scale: " + scale.name().toLowerCase());
                    writer.write("search-radius: 50");
                    writer.write("skip-known-structures: " + skipExistingChunks);
                }
                case "minecraft:set_potion" -> {
                    String potionType = trimNamespace(function.get("id").getAsString());
                    writer.write("potion-type: " + potionType);
                }
                case "minecraft:set_nbt", "minecraft:set_custom_data" -> {
                    if (name.contains("potion") || name.contains("tipped_arrow")) {
                        String potionTypeNbt = function.get("tag").getAsString();
                        writer.write("potion-type: " + potionTypeNbt.substring(potionTypeNbt.lastIndexOf(":") + 1, potionTypeNbt.lastIndexOf("\"")));
                    } else {
                        String tag = function.get("tag").getAsString().replaceAll(Pattern.quote("\\\""), "\"").replaceAll(Pattern.quote("'"), "''");
                        writer.write("nbt: '" + tag + "'");
                    }
                }
                case "minecraft:copy_nbt", "minecraft:copy_custom_data" -> {
                    if (name.contains("player_head") || name.contains("bee") || name.contains("banner") || name.contains("decorated_pot")) {
                        writer.write("copy-block-state: true");
                    } else if (!name.contains("shulker")) {
                        RoseLoot.getInstance().getLogger().warning("minecraft:copy_nbt unhandled: " + path);
                    }
                }
                case "minecraft:copy_state" -> writer.write("copy-block-data: true");
                case "minecraft:copy_name" -> writer.write("copy-block-name: true");
                case "minecraft:enchant_randomly" -> {
                    JsonElement enchantmentsElement = function.get("enchantments");
                    if (enchantmentsElement == null) {
                        writer.write("random-enchantments: []");
                    } else {
                        writer.write("random-enchantments:");
                        writer.increaseIndentation();
                        JsonArray randomEnchantments = enchantmentsElement.getAsJsonArray();
                        for (JsonElement enchantmentElement : randomEnchantments) {
                            String enchantment = trimNamespace(enchantmentElement.getAsString());
                            writer.write("- " + enchantment);
                        }
                        writer.decreaseIndentation();
                    }
                }
                case "minecraft:enchant_with_levels" -> {
                    writer.write("enchant-randomly:");
                    writer.increaseIndentation();
                    writeNumberProvider("level", "levels", writer, function, 30.0);
                    JsonElement treasureElement = function.get("treasure");
                    boolean treasure;
                    if (treasureElement != null) {
                        treasure = treasureElement.getAsBoolean();
                    } else {
                        JsonElement optionsElement = function.get("options");
                        if (optionsElement != null) {
                            String options = function.get("options").getAsString();
                            treasure = options.equals("#minecraft:on_random_loot");
                        } else {
                            treasure = false;
                        }
                    }
                    writer.write("treasure: " + treasure);
                    writer.decreaseIndentation();
                }
                case "minecraft:looting_enchant" -> {
                    writer.write("enchantment-bonus:");
                    writer.increaseIndentation();
                    writer.write("enchantment: looting");
                    writeNumberProvider("bonus-per-level", "count", writer, function, 0.0);
                    writeNumberProvider("max-bonus-levels", "limit", writer, function, null);
                    writer.decreaseIndentation();
                }
                case "minecraft:enchanted_count_increase" -> {
                    writer.write("enchantment-bonus:");
                    writer.increaseIndentation();
                    writer.write("enchantment: " + trimNamespace(function.get("enchantment").getAsString()));
                    writeNumberProvider("bonus-per-level", "count", writer, function, 0.0);
                    writeNumberProvider("max-bonus-levels", "limit", writer, function, null);
                    writer.decreaseIndentation();
                }
                case "minecraft:apply_bonus" -> {
                    writer.write("enchantment-bonus:");
                    writer.increaseIndentation();

                    String formula = trimNamespace(function.get("formula").getAsString());
                    writer.write("formula: " + formula);
                    writer.write("enchantment: " + trimNamespace(function.get("enchantment").getAsString()));

                    JsonElement parametersElement = function.get("parameters");
                    if (parametersElement != null) {
                        JsonObject parametersObject = parametersElement.getAsJsonObject();
                        switch (formula) {
                            case "uniform_bonus_count":
                                writeNumberProvider("bonus", "bonusMultiplier", writer, parametersObject, 1.0);
                                break;
                            case "binomial_with_bonus_count":
                                writeNumberProvider("bonus", "extra", writer, parametersObject, 1.0);
                                writeNumberProvider("probability", "probability", writer, parametersObject, 0.5);
                                break;
                            case "ore_drops":
                                break;
                            default:
                                RoseLoot.getInstance().getLogger().warning("minecraft:apply_bonus unhandled formula: " + formula);
                                break;
                        }
                    }

                    writer.decreaseIndentation();
                }
                case "minecraft:furnace_smelt" -> writer.write("smelt-if-burning: true");
                case "minecraft:explosion_decay" -> {
                    // Ignored, still handled by vanilla logic
                }
                case "minecraft:set_ominous_bottle_amplifier" -> {
                    writeNumberProvider("amplifier", "amplifier", writer, function, 0.0);
                }
                case "minecraft:set_components" -> {
                    JsonObject jsonObject = function.get("components").getAsJsonObject();
                    for (String key : jsonObject.keySet()) {
                        switch (key) {
                            case "minecraft:trim" -> {
                                JsonObject trim = jsonObject.get("minecraft:trim").getAsJsonObject();
                                String material = trimNamespace(trim.get("material").getAsString());
                                String pattern = trim.get("pattern").getAsString();
                                writer.write("trim: ");
                                writer.increaseIndentation();
                                writer.write("material: " + material);
                                writer.write("pattern: " + pattern);
                                writer.decreaseIndentation();
                            }
                            default -> RoseLoot.getInstance().getLogger().warning("minecraft:set_components unhandled key: " + key + " | " + path);
                        }
                    }
                }
                case "minecraft:copy_components" -> {
                    JsonArray includeArray = function.get("include").getAsJsonArray();
                    Set<String> valuesToWrite = new HashSet<>();
                    for (JsonElement includeElement : includeArray) {
                        String value = includeElement.getAsString();
                        switch (value) {
                            case "minecraft:pot_decorations",
                                 "minecraft:banner_patterns",
                                 "minecraft:hide_additional_tooltip",
                                 "minecraft:lock",
                                 "minecraft:container",
                                 "minecraft:container_loot",
                                 "minecraft:bees",
                                 "minecraft:profile",
                                 "minecraft:note_block_sound",
                                 "minecraft:rarity",
                                 "minecraft:tooltip_display" -> valuesToWrite.add("copy-block-state: true");
                            case "minecraft:custom_name", "minecraft:item_name" -> valuesToWrite.add("copy-block-name: true");
                            default -> RoseLoot.getInstance().getLogger().warning("minecraft:copy_components unhandled include: " + value + " | " + path);
                        }
                    }

                    for (String value : valuesToWrite)
                        writer.write(value);
                }
                default -> RoseLoot.getInstance().getLogger().warning("Unhandled item function type: " + type + " | " + path);
            }
        }
    }

    private static String fixEntityNames(String entityType) {
        // Apply replacements for spigot enums that are wrong
        if (NMSUtil.getVersionNumber() > 20 || (NMSUtil.getVersionNumber() == 20 && NMSUtil.getMinorVersionNumber() > 5)) {
            return entityType; // They were finally fixed
        } else {
            return switch (entityType) {
                case "snow_golem" -> "snowman";
                case "mooshroom" -> "mushroom_cow";
                default -> entityType;
            };
        }
    }

    private static String trimNamespace(String input) {
        if (input.startsWith(NAMESPACE))
            return input.substring(NAMESPACE_LENGTH);
        return input;
    }

    private record AmountModifierData(List<String> conditions, JsonObject parent, boolean add) {

        public void write(IndentedFileWriter writer) throws IOException {
            if (this.conditions.isEmpty()) {
                writer.write("conditions: []");
            } else {
                writer.write("conditions:");
                writer.increaseIndentation();
                for (String condition : this.conditions)
                    writer.write("- '" + condition + "'");
                writer.decreaseIndentation();
            }
            writeNumberProvider("value", "count", writer, this.parent, 1.0);
            writer.write("add: " + this.add);
        }

    }

}
